import logging
import os
import openai
import tempfile
import requests
import urllib.parse
from geopy.distance import geodesic
from telegram import Update, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from dotenv import load_dotenv

# --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏ –∑–∞–≥—Ä—É–∑–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è ---
context_history = []
MAX_TURNS = 6
MAX_DISTANCE_KM = 50  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ (–≤ –∫–º)

# –ó–∞–≥—Ä—É–∑–∫–∞ .env
load_dotenv()
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
GOOGLE_MAPS_API_KEY = os.getenv("GOOGLE_MAPS_API_KEY")
openai.api_key = OPENAI_API_KEY

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–æ–º—Ç–∞ —Å–∏—Å—Ç–µ–º—ã –¥–ª—è GPT
try:
    with open("prompt.txt", "r", encoding="utf-8") as f:
        SYSTEM_PROMPT = f.read()
except FileNotFoundError:
    SYSTEM_PROMPT = "–¢—ã ‚Äî –ú–∞–∫—Å. –î–∏—Å–ø–µ—Ç—á–µ—Ä, –ø–æ–º–æ—â–Ω–∏–∫ –∏ –Ω–∞–≤–∏–≥–∞—Ç–æ—Ä –ø–æ –∂–∏–∑–Ω–∏ –≤ —Ä–µ–π—Å–µ."
    logger.warning("–§–∞–π–ª prompt.txt –Ω–µ –Ω–∞–π–¥–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–∏—Å—Ç–µ–º–Ω—ã–π –ø—Ä–æ–º—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é.")

# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–∑–æ–π –∑–Ω–∞–Ω–∏–π ---
def load_relevant_knowledge(user_input: str) -> str:
    """
    –ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ —Ñ–∞–π–ª–æ–≤ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π
    –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –≤ –≤–≤–æ–¥–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
    """
    keywords_map = {
        "–æ—Ç–¥—ã—Ö": "Rezim_RTO.md",
        "–ø–∞—É–∑": "Rezim_RTO.md",
        "—Å–º–µ–Ω": "Rezim_RTO.md",
        "—Ç–∞—Ö–æ–≥—Ä–∞—Ñ": "4_tahograf_i_karty.md",
        "–∫–∞—Ä—Ç–∞": "4_tahograf_i_karty.md",
        "–ø–æ–µ–∑–¥": "ferry_routes.md",
        "–ø–∞—Ä–æ–º": "ferry_routes.md",
        "—Ü–º—Ä": "CMR.md",
        "–¥–æ–∫—É–º–µ–Ω—Ç": "CMR.md",
        "–∫–æ–º—Ñ–æ—Ä—Ç": "11_komfort_i_byt.md",
        "–ø–∏—Ç–∞–Ω–∏–µ": "12_pitanie_i_energiya.md"
    }

    selected_files = set()
    lowered = user_input.lower()
    for keyword, filename in keywords_map.items():
        if keyword in lowered:
            selected_files.add(filename)

    texts = []
    for filename in sorted(selected_files):
        path = os.path.join("knowledge", filename)
        if os.path.exists(path):
            try:
                with open(path, "r", encoding="utf-8") as f:
                    content = f.read().strip()
                    if content:
                        texts.append(f"üìò {filename}:\n{content}\n")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞ –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π {filename}: {e}")
        else:
            logger.warning(f"–§–∞–π–ª –±–∞–∑—ã –∑–Ω–∞–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω: {path}")

    return "\n".join(texts) or ""

# --- –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å GPT ---
async def ask_gpt(messages: list) -> dict:
    """
    –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ GPT-–º–æ–¥–µ–ª–∏, –ø—ã—Ç–∞—è—Å—å —Å–Ω–∞—á–∞–ª–∞ GPT-4.5, –∑–∞—Ç–µ–º GPT-3.5.
    """
    try:
        response = await openai.ChatCompletion.acreate(model="gpt-4.5-preview", messages=messages)
        return response
    except openai.error.OpenAIError as e:
        logger.warning(f"GPT-4.5-preview –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω, fallback –∫ GPT-3.5: {e}")
        try:
            response = await openai.ChatCompletion.acreate(model="gpt-3.5-turbo-1106", messages=messages)
            return response
        except openai.error.OpenAIError as e2:
            logger.error(f"GPT-3.5 —Ç–æ–∂–µ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e2}")
            return None
    except Exception as e:
        logger.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ OpenAI API: {e}")
        return None

# --- –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥ –∏ —Å–æ–æ–±—â–µ–Ω–∏–π Telegram ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /start."""
    await update.message.reply_text("–ó–¥–æ—Ä–æ–≤–∞, —è ‚Äî –ú–∞–∫—Å. –î–∏—Å–ø–µ—Ç—á–µ—Ä, –¥—Ä—É–≥ –∏ –Ω–∞–ø–∞—Ä–Ω–∏–∫. –ü–∏—à–∏, –≥–æ–≤–æ—Ä–∏ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–π –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã ‚Äî —Ä–∞–∑–±–µ—Ä—ë–º—Å—è!")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    user_input = update.message.text.strip()
    if not user_input:
        await update.message.reply_text("–ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?")
        return

    lowered = user_input.lower()

    if any(keyword in lowered for keyword in ["–Ω–∞—Ä–∏—Å—É–π", "–ø–æ–∫–∞–∂–∏", "—Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π", "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", "–∫–∞—Ä—Ç–∏–Ω–∫—É", "–∫–∞—Ä—Ç–∏–Ω–∞"]):
        try:
            image_response = await openai.Image.acreate(prompt=user_input, n=1, size="512x512")
            image_url = image_response['data'][0]['url']
            await update.message.reply_photo(photo=image_url, caption="üñºÔ∏è –í–æ—Ç –∫–∞–∫ —ç—Ç–æ –º–æ–∂–µ—Ç –≤—ã–≥–ª—è–¥–µ—Ç—å:")
            return
        except openai.error.OpenAIError as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ OpenAI API: {e}")
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ —Å API –∏–ª–∏ –∑–∞–ø—Ä–æ—Å–æ–º. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")
            return
        except Exception as e:
            logger.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {e}")
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")
            return

    context_history.append({"role": "user", "content": user_input})
    messages = [{"role": "system", "content": SYSTEM_PROMPT}]
    
    kb_snippet = load_relevant_knowledge(user_input)
    if kb_snippet:
        messages.append({"role": "system", "content": "üìö –ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π:\n" + kb_snippet})
    
    messages.extend(context_history[-MAX_TURNS:])

    response = await ask_gpt(messages)
    if response and response.choices:
        assistant_reply = response.choices[0].message.content.strip()
        context_history.append({"role": "assistant", "content": assistant_reply})
        await update.message.reply_text(assistant_reply)
    else:
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ GPT. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")

async def handle_voice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."""
    try:
        file = await update.message.voice.get_file()
        with tempfile.NamedTemporaryFile(delete=False, suffix=".oga") as f:
            await file.download_to_drive(f.name)
            audio_path = f.name

        with open(audio_path, "rb") as audio_file:
            transcript = await openai.Audio.atranscribe("whisper-1", audio_file)
            user_text = transcript.get("text", "")
        
        os.remove(audio_path)

        if not user_text:
            await update.message.reply_text("üéß –ù–µ —Å–º–æ–≥ —Ä–∞–∑–æ–±—Ä–∞—Ç—å –≥–æ–ª–æ—Å. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞.")
            return

        await update.message.reply_text(f"–¢—ã —Å–∫–∞–∑–∞–ª: \"{user_text}\"")

        context_history.append({"role": "user", "content": user_text})
        messages = [{"role": "system", "content": SYSTEM_PROMPT}]
        kb_snippet = load_relevant_knowledge(user_text)
        if kb_snippet:
            messages.append({"role": "system", "content": "üìö –ë–∞–∑–∞ –∑–Ω–∞–Ω–∏–π:\n" + kb_snippet})
        messages.extend(context_history[-MAX_TURNS:])

        response = await ask_gpt(messages)
        if response and response.choices:
            assistant_reply = response.choices[0].message.content.strip()
            context_history.append({"role": "assistant", "content": assistant_reply})
            await update.message.reply_text(assistant_reply)
        else:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –∫ GPT. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")

    except openai.error.OpenAIError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ç—Ä–∞–Ω—Å–∫—Ä–∏–±–∞—Ü–∏–∏ –≥–æ–ª–æ—Å–∞ —á–µ—Ä–µ–∑ OpenAI API: {e}")
        await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞—Ç—å –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ —Å API.")
    except Exception as e:
        logger.error(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è: {e}", exc_info=True)
        await update.message.reply_text("‚ö†Ô∏è –ù–µ —Å–º–æ–≥ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –≥–æ–ª–æ—Å. –í–æ–∑–º–æ–∂–Ω–æ, –ø—Ä–æ–±–ª–µ–º–∞ —Å —Ñ–æ—Ä–º–∞—Ç–æ–º –∏–ª–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞.")
    finally:
        if 'audio_path' in locals() and os.path.exists(audio_path):
            os.remove(audio_path)

async def handle_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –≤—ã–±–æ—Ä –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –ø–æ–∏—Å–∫–∞."""
    try:
        lat = update.message.location.latitude
        lon = update.message.location.longitude
        context.user_data['last_location'] = (lat, lon)  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
        await update.message.reply_text(
            "üìç –ü–æ–ª—É—á–∏–ª –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã. –í—ã–±–µ—Ä–∏ –∏—Å—Ç–æ—á–Ω–∏–∫ –ø–æ–∏—Å–∫–∞:",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("Google Maps", callback_data=f"search_google|{lat}|{lon}")],
                [InlineKeyboardButton("OpenStreetMap (Overpass)", callback_data=f"search_overpass|{lat}|{lon}")]
            ])
        )
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≥–µ–æ–ª–æ–∫–∞—Ü–∏–∏: {e}", exc_info=True)
        await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç. –ü–æ–ø—Ä–æ–±—É–π –ø–æ–∑–∂–µ.")

async def handle_callback_query(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –ø–æ–∏—Å–∫–∞."""
    query = update.callback_query
    await query.answer()
    action, lat, lon = query.data.split("|")
    lat, lon = float(lat), float(lon)

    if action == "search_google":
        await search_with_google(update, context, lat, lon)
    elif action == "search_overpass":
        await search_with_overpass(update, context, lat, lon)

async def search_with_google(update: Update, context: ContextTypes.DEFAULT_TYPE, lat: float, lon: float):
    """–ü–æ–∏—Å–∫ –º–µ—Å—Ç —á–µ—Ä–µ–∑ Google Places API —Å —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é."""
    try:
        place_queries = [
            {"label": "üå≥ –ü—Ä–æ–≥—É–ª–∫–∞/–î–æ—Å—Ç.", "type": "tourist_attraction", "keyword": "–ø–∞—Ä–∫|–¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å|–æ—Ç–¥—ã—Ö", "radius": 5000},
            {"label": "üå≥ –ü—Ä–æ–≥—É–ª–∫–∞/–î–æ—Å—Ç.", "type": "park", "keyword": "", "radius": 5000},
            {"label": "üöõ –ü–∞—Ä–∫–æ–≤–∫–∞ –¥–ª—è —Ñ—É—Ä", "type": "parking", "keyword": "–≥—Ä—É–∑–æ–≤–∞—è –ø–∞—Ä–∫–æ–≤–∫–∞|truck parking", "radius": 10000},
            {"label": "üè® –û—Ç–µ–ª—å/–ú–æ—Ç–µ–ª—å", "type": "lodging", "keyword": "–º–æ—Ç–µ–ª—å|–≥–æ—Å—Ç–∏–Ω–∏—Ü–∞|hotel|motel", "radius": 10000},
            {"label": "üõí –ú–∞–≥–∞–∑–∏–Ω (–ø—Ä–æ–¥—É–∫—Ç—ã)", "type": "supermarket", "keyword": "", "radius": 5000},
            {"label": "üõí –ú–∞–≥–∞–∑–∏–Ω (–ø—Ä–æ–¥—É–∫—Ç—ã)", "type": "convenience_store", "keyword": "", "radius": 5000},
            {"label": "üß∫ –ü—Ä–∞—á–µ—á–Ω–∞—è", "type": "laundry", "keyword": "–ø—Ä–∞—á–µ—á–Ω–∞—è|—Å–∞–º–æ–æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ|laundromat", "radius": 5000},
            {"label": "üß∫ –ü—Ä–∞—á–µ—á–Ω–∞—è", "type": None, "keyword": "–ø—Ä–∞—á–µ—á–Ω–∞—è —Å–∞–º–æ–æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è|self-service laundry", "radius": 5000},
            {"label": "üöø –î—É—à–µ–≤—ã–µ", "type": "gas_station", "keyword": "truck stop|–¥—É—à–µ–≤—ã–µ|–¥—É—à –¥–ª—è –¥–∞–ª—å–Ω–æ–±–æ–π—â–∏–∫–æ–≤", "radius": 10000},
            {"label": "üöø –î—É—à–µ–≤—ã–µ", "type": None, "keyword": "–¥—É—à|—Å–∞—É–Ω–∞|truck stop showers", "radius": 10000},
        ]

        found_results_grouped = {}
        base_url = "https://maps.googleapis.com/maps/api/place/"
        user_location = (lat, lon)

        for query_info in place_queries:
            label = query_info["label"]
            place_type = query_info.get("type")
            keyword = query_info.get("keyword")
            radius = query_info.get("radius", 5000)

            url = ""
            if place_type and not keyword:
                url = (
                    f"{base_url}nearbysearch/json"
                    f"?location={lat},{lon}&type={place_type}&key={GOOGLE_MAPS_API_KEY}&language=ru&rankby=distance"
                )
            elif keyword:
                query_str = urllib.parse.quote(f"{keyword} —Ä—è–¥–æ–º —Å {lat},{lon}")
                url = (
                    f"{base_url}textsearch/json"
                    f"?query={query_str}&radius={radius}&key={GOOGLE_MAPS_API_KEY}&language=ru"
                )
            else:
                logger.warning(f"–ü—Ä–æ–ø—É—â–µ–Ω –∑–∞–ø—Ä–æ—Å: –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {label}")
                continue

            try:
                logger.info(f"Google API –∑–∞–ø—Ä–æ—Å –¥–ª—è {label}: {url}")
                res = requests.get(url)
                res.raise_for_status()
                data = res.json()

                if data.get("results"):
                    if label not in found_results_grouped:
                        found_results_grouped[label] = []
                    for place in data["results"][:3]:
                        name = place.get("name")
                        address = place.get("vicinity", "–ë–µ–∑ –∞–¥—Ä–µ—Å–∞")
                        loc = place["geometry"]["location"]
                        place_location = (loc["lat"], loc["lng"])
                        distance_km = geodesic(user_location, place_location).kilometers

                        if distance_km <= MAX_DISTANCE_KM:
                            place_id = place["place_id"]
                            maps_url = f"https://www.google.com/maps/dir/?api=1&origin={lat},{lon}&destination={loc['lat']},{loc['lng']}&travelmode=driving"
                            if (name, address) not in [(item[0], item[1]) for item in found_results_grouped[label]]:
                                found_results_grouped[label].append((name, address, maps_url, distance_km))
            except requests.exceptions.RequestException as e:
                logger.error(f"–û—à–∏–±–∫–∞ HTTP –∑–∞–ø—Ä–æ—Å–∞ Google API –¥–ª—è {label}: {e}")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö Google API –¥–ª—è {label}: {e}")

        if found_results_grouped:
            reply = "üìå –ù–∞—à—ë–ª —Ç–∞–∫–∏–µ –º–µ—Å—Ç–∞ —Ä—è–¥–æ–º (Google Maps):\n\n"
            buttons = []
            for label, places in found_results_grouped.items():
                reply += f"**{label}**:\n"
                places.sort(key=lambda x: x[3])  # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
                for name, address, url, distance_km in places:
                    reply += f"  ‚Ä¢ **{name}** ({distance_km:.1f} –∫–º)\n    üìç {address}\n    üîó [–ú–∞—Ä—à—Ä—É—Ç]({url})\n"
                    buttons.append([InlineKeyboardButton(text=f"{label}: {name} ({distance_km:.1f} –∫–º)", url=url)])
                reply += "\n"
            await update.callback_query.message.reply_markdown(reply, reply_markup=InlineKeyboardMarkup(buttons))
        else:
            await update.callback_query.message.reply_text("üòî –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à—ë–ª –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ (Google Maps).")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ Google API: {e}", exc_info=True)
        await update.callback_query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ —á–µ—Ä–µ–∑ Google Maps.")

async def search_with_overpass(update: Update, context: ContextTypes.DEFAULT_TYPE, lat: float, lon: float):
    """–ü–æ–∏—Å–∫ –º–µ—Å—Ç —á–µ—Ä–µ–∑ Overpass API (OpenStreetMap) —Å –º–∞—Ä—à—Ä—É—Ç–∞–º–∏ –≤ Google Maps."""
    try:
        place_queries = [
            {"label": "üå≥ –ü—Ä–æ–≥—É–ª–∫–∞/–î–æ—Å—Ç.", "query": f'node["tourism"="attraction"](around:5000,{lat},{lon});node["leisure"="park"](around:5000,{lat},{lon});'},
            {"label": "üöõ –ü–∞—Ä–∫–æ–≤–∫–∞ –¥–ª—è —Ñ—É—Ä", "query": f'node["highway"="services"]["access"="truck"](around:10000,{lat},{lon});'},
            {"label": "üè® –û—Ç–µ–ª—å/–ú–æ—Ç–µ–ª—å", "query": f'node["tourism"~"hotel|motel"](around:10000,{lat},{lon});'},
            {"label": "üõí –ú–∞–≥–∞–∑–∏–Ω (–ø—Ä–æ–¥—É–∫—Ç—ã)", "query": f'node["shop"="supermarket"](around:5000,{lat},{lon});'},
            {"label": "üß∫ –ü—Ä–∞—á–µ—á–Ω–∞—è", "query": f'node["shop"="laundry"](around:5000,{lat},{lon});'},
            {"label": "üöø –î—É—à–µ–≤—ã–µ", "query": f'node["amenity"="shower"](around:10000,{lat},{lon});'},
        ]

        found_results_grouped = {}
        overpass_url = "http://overpass-api.de/api/interpreter"
        user_location = (lat, lon)

        for query_info in place_queries:
            label = query_info["label"]
            overpass_query = f"[out:json];{query_info['query']}out body;"

            try:
                logger.info(f"Overpass API –∑–∞–ø—Ä–æ—Å –¥–ª—è {label}: {overpass_query}")
                res = requests.post(overpass_url, data={"data": overpass_query})
                res.raise_for_status()
                data = res.json()

                if data.get("elements"):
                    if label not in found_results_grouped:
                        found_results_grouped[label] = []
                    for element in data["elements"][:3]:
                        name = element["tags"].get("name", "–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è")
                        # –°–æ–±–∏—Ä–∞–µ–º –∞–¥—Ä–µ—Å –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Ç–µ–≥–æ–≤
                        address_parts = []
                        for tag in ["addr:street", "addr:housenumber", "addr:city", "addr:country"]:
                            if tag in element["tags"]:
                                address_parts.append(element["tags"][tag])
                        address = ", ".join(address_parts) if address_parts else "–ë–µ–∑ –∞–¥—Ä–µ—Å–∞"
                        el_lat, el_lon = element["lat"], element["lon"]
                        place_location = (el_lat, el_lon)
                        distance_km = geodesic(user_location, place_location).kilometers

                        if distance_km <= MAX_DISTANCE_KM:
                            # –§–æ—Ä–º–∏—Ä—É–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ Google Maps —Å –º–∞—Ä—à—Ä—É—Ç–æ–º
                            maps_url = f"https://www.google.com/maps/dir/?api=1&origin={lat},{lon}&destination={el_lat},{el_lon}&travelmode=driving"
                            if (name, address) not in [(item[0], item[1]) for item in found_results_grouped[label]]:
                                found_results_grouped[label].append((name, address, maps_url, distance_km))
            except requests.exceptions.RequestException as e:
                logger.error(f"–û—à–∏–±–∫–∞ HTTP –∑–∞–ø—Ä–æ—Å–∞ Overpass API –¥–ª—è {label}: {e}")
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö Overpass API –¥–ª—è {label}: {e}")

        if found_results_grouped:
            reply = "üìå –ù–∞—à—ë–ª —Ç–∞–∫–∏–µ –º–µ—Å—Ç–∞ —Ä—è–¥–æ–º (OpenStreetMap):\n\n"
            buttons = []
            for label, places in found_results_grouped.items():
                reply += f"**{label}**:\n"
                places.sort(key=lambda x: x[3])  # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
                for name, address, url, distance_km in places:
                    reply += f"  ‚Ä¢ **{name}** ({distance_km:.1f} –∫–º)\n    üìç {address}\n    üîó [–ú–∞—Ä—à—Ä—É—Ç]({url})\n"
                    buttons.append([InlineKeyboardButton(text=f"{label}: {name} ({distance_km:.1f} –∫–º)", url=url)])
                reply += "\n"
            await update.callback_query.message.reply_markdown(reply, reply_markup=InlineKeyboardMarkup(buttons))
        else:
            await update.callback_query.message.reply_text("üòî –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à—ë–ª –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏ (OpenStreetMap). –ü–æ–ø—Ä–æ–±—É–π Google Maps –∏–ª–∏ —É—Ç–æ—á–Ω–∏ –∑–∞–ø—Ä–æ—Å.")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ Overpass API: {e}", exc_info=True)
        await update.callback_query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ —á–µ—Ä–µ–∑ OpenStreetMap.")

# --- –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞ ---
if __name__ == '__main__':
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    
    # –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_handler(MessageHandler(filters.VOICE, handle_voice))
    app.add_handler(MessageHandler(filters.LOCATION, handle_location))
    app.add_handler(CallbackQueryHandler(handle_callback_query))
    
    logger.info("–ë–æ—Ç –∑–∞–ø—É—â–µ–Ω. –û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π...")
    app.run_polling()
